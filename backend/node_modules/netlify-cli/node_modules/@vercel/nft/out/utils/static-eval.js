"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.wildcardRegEx = exports.WILDCARD = exports.FUNCTION = exports.UNKNOWN = exports.evaluate = void 0;
const url_1 = require("url");
async function evaluate(ast, vars = {}, computeBranches = true) {
    const state = {
        computeBranches,
        vars,
    };
    return walk(ast);
    // walk returns:
    // 1. Single known value: { value: value }
    // 2. Conditional value: { test, then, else }
    // 3. Unknown value: undefined
    function walk(node) {
        const visitor = visitors[node.type];
        if (visitor) {
            return visitor.call(state, node, walk);
        }
        return undefined;
    }
}
exports.evaluate = evaluate;
exports.UNKNOWN = Symbol();
exports.FUNCTION = Symbol();
exports.WILDCARD = '\x1a';
exports.wildcardRegEx = /\x1a/g;
function countWildcards(str) {
    exports.wildcardRegEx.lastIndex = 0;
    let cnt = 0;
    while (exports.wildcardRegEx.exec(str))
        cnt++;
    return cnt;
}
const visitors = {
    ArrayExpression: async function ArrayExpression(node, walk) {
        const arr = [];
        for (let i = 0, l = node.elements.length; i < l; i++) {
            if (node.elements[i] === null) {
                arr.push(null);
                continue;
            }
            const x = await walk(node.elements[i]);
            if (!x)
                return;
            if ('value' in x === false)
                return;
            arr.push(x.value);
        }
        return { value: arr };
    },
    ArrowFunctionExpression: async function (node, walk) {
        // () => val support only
        if (node.params.length === 0 &&
            !node.generator &&
            !node.async &&
            node.expression) {
            const innerValue = await walk(node.body);
            if (!innerValue || !('value' in innerValue))
                return;
            return {
                value: {
                    [exports.FUNCTION]: () => innerValue.value,
                },
            };
        }
        return undefined;
    },
    BinaryExpression: async function BinaryExpression(node, walk) {
        const op = node.operator;
        let l = await walk(node.left);
        if (!l && op !== '+')
            return;
        let r = await walk(node.right);
        if (!l && !r)
            return;
        if (!l) {
            // UNKNOWN + 'str' -> wildcard string value
            if (this.computeBranches &&
                r &&
                'value' in r &&
                typeof r.value === 'string')
                return {
                    value: exports.WILDCARD + r.value,
                    wildcards: [node.left, ...(r.wildcards || [])],
                };
            return;
        }
        if (!r) {
            // 'str' + UKNOWN -> wildcard string value
            if (this.computeBranches && op === '+') {
                if (l && 'value' in l && typeof l.value === 'string')
                    return {
                        value: l.value + exports.WILDCARD,
                        wildcards: [...(l.wildcards || []), node.right],
                    };
            }
            // A || UNKNOWN -> A if A is truthy
            if (!('test' in l) && op === '||' && l.value)
                return l;
            return;
        }
        if ('test' in l && 'value' in r) {
            const v = r.value;
            if (op === '==')
                return { test: l.test, then: l.then == v, else: l.else == v };
            if (op === '===')
                return { test: l.test, then: l.then === v, else: l.else === v };
            if (op === '!=')
                return { test: l.test, then: l.then != v, else: l.else != v };
            if (op === '!==')
                return { test: l.test, then: l.then !== v, else: l.else !== v };
            if (op === '+')
                return { test: l.test, then: l.then + v, else: l.else + v };
            if (op === '-')
                return { test: l.test, then: l.then - v, else: l.else - v };
            if (op === '*')
                return { test: l.test, then: l.then * v, else: l.else * v };
            if (op === '/')
                return { test: l.test, then: l.then / v, else: l.else / v };
            if (op === '%')
                return { test: l.test, then: l.then % v, else: l.else % v };
            if (op === '<')
                return { test: l.test, then: l.then < v, else: l.else < v };
            if (op === '<=')
                return { test: l.test, then: l.then <= v, else: l.else <= v };
            if (op === '>')
                return { test: l.test, then: l.then > v, else: l.else > v };
            if (op === '>=')
                return { test: l.test, then: l.then >= v, else: l.else >= v };
            if (op === '|')
                return { test: l.test, then: l.then | v, else: l.else | v };
            if (op === '&')
                return { test: l.test, then: l.then & v, else: l.else & v };
            if (op === '^')
                return { test: l.test, then: l.then ^ v, else: l.else ^ v };
            if (op === '&&')
                return { test: l.test, then: l.then && v, else: l.else && v };
            if (op === '||')
                return { test: l.test, then: l.then || v, else: l.else || v };
        }
        else if ('test' in r && 'value' in l) {
            const v = l.value;
            if (op === '==')
                return { test: r.test, then: v == r.then, else: v == r.else };
            if (op === '===')
                return { test: r.test, then: v === r.then, else: v === r.else };
            if (op === '!=')
                return { test: r.test, then: v != r.then, else: v != r.else };
            if (op === '!==')
                return { test: r.test, then: v !== r.then, else: v !== r.else };
            if (op === '+')
                return { test: r.test, then: v + r.then, else: v + r.else };
            if (op === '-')
                return { test: r.test, then: v - r.then, else: v - r.else };
            if (op === '*')
                return { test: r.test, then: v * r.then, else: v * r.else };
            if (op === '/')
                return { test: r.test, then: v / r.then, else: v / r.else };
            if (op === '%')
                return { test: r.test, then: v % r.then, else: v % r.else };
            if (op === '<')
                return { test: r.test, then: v < r.then, else: v < r.else };
            if (op === '<=')
                return { test: r.test, then: v <= r.then, else: v <= r.else };
            if (op === '>')
                return { test: r.test, then: v > r.then, else: v > r.else };
            if (op === '>=')
                return { test: r.test, then: v >= r.then, else: v >= r.else };
            if (op === '|')
                return { test: r.test, then: v | r.then, else: v | r.else };
            if (op === '&')
                return { test: r.test, then: v & r.then, else: v & r.else };
            if (op === '^')
                return { test: r.test, then: v ^ r.then, else: v ^ r.else };
            if (op === '&&')
                return { test: r.test, then: v && r.then, else: l && r.else };
            if (op === '||')
                return { test: r.test, then: v || r.then, else: l || r.else };
        }
        else if ('value' in l && 'value' in r) {
            if (op === '==')
                return { value: l.value == r.value };
            if (op === '===')
                return { value: l.value === r.value };
            if (op === '!=')
                return { value: l.value != r.value };
            if (op === '!==')
                return { value: l.value !== r.value };
            if (op === '+') {
                const val = { value: l.value + r.value };
                let wildcards = [];
                if ('wildcards' in l && l.wildcards) {
                    wildcards = wildcards.concat(l.wildcards);
                }
                if ('wildcards' in r && r.wildcards) {
                    wildcards = wildcards.concat(r.wildcards);
                }
                if (wildcards.length > 0) {
                    val.wildcards = wildcards;
                }
                return val;
            }
            if (op === '-')
                return { value: l.value - r.value };
            if (op === '*')
                return { value: l.value * r.value };
            if (op === '/')
                return { value: l.value / r.value };
            if (op === '%')
                return { value: l.value % r.value };
            if (op === '<')
                return { value: l.value < r.value };
            if (op === '<=')
                return { value: l.value <= r.value };
            if (op === '>')
                return { value: l.value > r.value };
            if (op === '>=')
                return { value: l.value >= r.value };
            if (op === '|')
                return { value: l.value | r.value };
            if (op === '&')
                return { value: l.value & r.value };
            if (op === '^')
                return { value: l.value ^ r.value };
            if (op === '&&')
                return { value: l.value && r.value };
            if (op === '||')
                return { value: l.value || r.value };
        }
        return;
    },
    CallExpression: async function CallExpression(node, walk) {
        const callee = await walk(node.callee);
        if (!callee || 'test' in callee)
            return;
        let fn = callee.value;
        if (typeof fn === 'object' && fn !== null)
            fn = fn[exports.FUNCTION];
        if (typeof fn !== 'function')
            return;
        let ctx = null;
        if (node.callee.object) {
            ctx = await walk(node.callee.object);
            ctx = ctx && 'value' in ctx && ctx.value ? ctx.value : null;
        }
        // we allow one conditional argument to create a conditional expression
        let predicate;
        let args = [];
        let argsElse;
        let allWildcards = node.arguments.length > 0 && node.callee.property?.name !== 'concat';
        const wildcards = [];
        for (let i = 0, l = node.arguments.length; i < l; i++) {
            let x = await walk(node.arguments[i]);
            if (x) {
                allWildcards = false;
                if ('value' in x && typeof x.value === 'string' && x.wildcards)
                    x.wildcards.forEach((w) => wildcards.push(w));
            }
            else {
                if (!this.computeBranches)
                    return;
                // this works because provided static functions
                // operate on known string inputs
                x = { value: exports.WILDCARD };
                wildcards.push(node.arguments[i]);
            }
            if ('test' in x) {
                if (wildcards.length)
                    return;
                if (predicate)
                    return;
                predicate = x.test;
                argsElse = args.concat([]);
                args.push(x.then);
                argsElse.push(x.else);
            }
            else {
                args.push(x.value);
                if (argsElse)
                    argsElse.push(x.value);
            }
        }
        if (allWildcards)
            return;
        try {
            const result = await fn.apply(ctx, args);
            if (result === exports.UNKNOWN)
                return;
            if (!predicate) {
                if (wildcards.length) {
                    if (typeof result !== 'string' ||
                        countWildcards(result) !== wildcards.length)
                        return;
                    return { value: result, wildcards };
                }
                return { value: result };
            }
            const resultElse = await fn.apply(ctx, argsElse);
            if (result === exports.UNKNOWN)
                return;
            return { test: predicate, then: result, else: resultElse };
        }
        catch (e) {
            return;
        }
    },
    ConditionalExpression: async function ConditionalExpression(node, walk) {
        const val = await walk(node.test);
        if (val && 'value' in val)
            return val.value ? walk(node.consequent) : walk(node.alternate);
        if (!this.computeBranches)
            return;
        const thenValue = await walk(node.consequent);
        if (!thenValue || 'wildcards' in thenValue || 'test' in thenValue)
            return;
        const elseValue = await walk(node.alternate);
        if (!elseValue || 'wildcards' in elseValue || 'test' in elseValue)
            return;
        return {
            test: node.test,
            then: thenValue.value,
            else: elseValue.value,
        };
    },
    ExpressionStatement: async function ExpressionStatement(node, walk) {
        return walk(node.expression);
    },
    Identifier: async function Identifier(node, _walk) {
        if (Object.hasOwnProperty.call(this.vars, node.name))
            return this.vars[node.name];
        return undefined;
    },
    Literal: async function Literal(node, _walk) {
        return { value: node.value };
    },
    MemberExpression: async function MemberExpression(node, walk) {
        const obj = await walk(node.object);
        if (!obj || 'test' in obj || typeof obj.value === 'function') {
            return undefined;
        }
        if (node.property.type === 'Identifier') {
            if (typeof obj.value === 'string' && node.property.name === 'concat') {
                return {
                    value: {
                        [exports.FUNCTION]: (...args) => obj.value.concat(args),
                    },
                };
            }
            if